## step1 とりあえず解く
- 計算量
  - 時間:O(N^2)
  - 空間:O(N)
- stackをいい感じに使う解法が思いつかず愚直にreplaceした

```java
class Solution {
    public boolean isValid(String s) {
        while (s.contains("[]") || s.contains("{}") || s.contains("()")){
            s = s.replace("{}", "");
            s = s.replace("[]", "");
            s = s.replace("()", "");
        }
        return s.isEmpty();
    }
}

```


## step2 他の人の回答を見る
- 計算量
  - 時間:O(N)
  - 空間:O(N)
- 開きカッコと閉じカッコの対応をMapで保持して、閉じかっこが来た時にStackの一番上が開きカッコであるか確認する
- Stack型が初見だったので、次の問題ではStackに関する問題を解いて理解を深める
  - https://docs.oracle.com/javase/jp/17/docs/api/java.base/java/util/Stack.html
- 開きカッコと閉じカッコの対応Mapの命名がとてもいいなと思った

```java
public class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        Map<Character, Character> closeToOpen = new HashMap<>();
        closeToOpen.put(')', '(');
        closeToOpen.put(']', '[');
        closeToOpen.put('}', '{');

        for (char c : s.toCharArray()) {
            if (closeToOpen.containsKey(c)) {
                if (!stack.isEmpty() && stack.peek() == closeToOpen.get(c)) {
                    stack.pop();
                } else {
                    return false;
                }
            } else {
                stack.push(c);
            }
        }
        return stack.isEmpty();
    }
}
```

## step3 3回とく
- step2のまま
- ネストが若干深いため、下記のような感じで早期returnしてもいいかなと感じたが否定系のチェック `!closeToOpen.containsKey(c)` を使うことで可読性が落ちると感じたため採用していない

```java
if (!closeToOpen.containsKey(c)) {
    stack.push(c);
    continue;
}
if (!stack.isEmpty() && stack.peek() == closeToOpen.get(c)){
    stack.pop();
} else {
    return false;
}
```

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        Map<Character, Character> closeToOpen = new HashMap<>();
        closeToOpen.put(']', '[');
        closeToOpen.put('}', '{');
        closeToOpen.put(')', '(');
        for (Character c : s.toCharArray()) {
            if (closeToOpen.containsKey(c)) {
                if (!stack.isEmpty() && stack.peek() == closeToOpen.get(c)){
                    stack.pop();
                } else {
                    return false;
                }
            } else {
                stack.push(c);
            }
        }
        return stack.isEmpty();
    }
}
```