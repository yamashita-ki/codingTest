## step1 とりあえず解く
- 計算量
  - 時間:O(N)
  - 空間:O(1)
- まず思いついた全探索

```java
class Solution {
    public int search(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                return i;
            }
        }
        return -1;
    }
}

```

## step2 他の人の回答を見る
- 計算量
  - 時間:O(logN)
  - 空間:O(1)
- ビルドインで提供されているメソッドを使う
    - 「キーが見つかった場合にのみ戻り値が>= 0になることが保証される。」らしい
    - https://docs.oracle.com/javase/jp/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-
- 面接でライブラリの使用が許されていないかも？

```java
public class Solution {
    public int search(int[] nums, int target) {
        int index = Arrays.binarySearch(nums, target);
        return index >= 0 ? index : -1;
    }
}

```

- 計算量
  - 時間:O(logN)
  - 空間:O(1)
- 一番よく見る二分探索

```java
public class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] < target) {
                left = middle + 1;
            } else {
                return middle;
            }
        }
        return -1;
    }
}

```

- 計算量
  - 時間:O(logN)
  - 空間:O(1)
- Upper Bound
- targetを超える最初のindexを返す、そのためreturnで調整している

```java
public class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;

        while (left < right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] > target) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return (left > 0 && nums[left - 1] == target) ? left - 1 : -1;
    }
}
```

- 計算量
  - 時間:O(logN)
  - 空間:O(1)
- Lower Bound
- target以上の最初の要素を探す

```java
public class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;

        while (left < right) {
            int middle = left + (right - left) / 2;
            if (nums[middle] >= target) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return (left < nums.length && nums[left] == target) ? left : -1;
    }
}
```

## step3 3回とく
- 今回の問題には古典的な二分探索が最適だと感じたのでそのまま

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int middle = (left + right) / 2;
            if (nums[middle] == target) {
                return middle;
            } else if (target > nums[middle]) {
                left = middle + 1;
            } else {
                right = middle - 1;
            }
        }
        return -1;
    }
}

```