## step1 とりあえず解く
- 計算量
  - 時間: O(N * M) N, Mはそれぞれパスの長さ
  - 空間: O(N + M)
- p, qそれぞれに到着するまでにたどった経路を保存するやり方
- dequeを使うまでもなかったかも
- そもそも回答を見ると経路保存すら要らなかった><

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode temp = root;
        Deque<TreeNode> visitedNodeOfP = findVisitedNode(new ArrayDeque<TreeNode>(), temp, p);
        temp = root;
        Deque<TreeNode> visitedNodeOfQ = findVisitedNode(new ArrayDeque<TreeNode>(), temp, q);
        TreeNode ans = new TreeNode(0);
        for(TreeNode visitedP : visitedNodeOfP) {
            for(TreeNode visitedQ : visitedNodeOfQ) {
                System.out.println(visitedP.val + " : " + visitedQ.val);
                if (visitedQ.val == visitedP.val) {
                    ans = visitedQ;
                }
            }
        }
        return ans;
    }

    private Deque<TreeNode> findVisitedNode(Deque<TreeNode> visitedNode, TreeNode node, TreeNode destinationNode) {
        visitedNode.addLast(node);
        if (destinationNode.val == node.val) {
            return visitedNode;
        } else if (destinationNode.val < node.val) {
            node = node.left;
            findVisitedNode(visitedNode, node, destinationNode);
        } else {
            node = node.right;
            findVisitedNode(visitedNode, node, destinationNode);
        }
        return visitedNode;
    }
}

```

## step2 他の人の回答を見る
- 計算量
  - 時間：O(h)
    - hはツリーの高さ
  - 空間：O(1)
- p,qに向けて辿り、親ノードが分岐したタイミングが回答になるs

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode currentNode = root;
        while (currentNode != null) {
            if (currentNode.val < p.val && currentNode.val < q.val) {
                currentNode = currentNode.right;
            } else if (p.val < currentNode.val && q.val < currentNode.val) {
                currentNode = currentNode.left;
            } else {
                return currentNode;
            }
        }
        return currentNode;
    }
}

```

## step3 3回とく
- step2で解いた