## step1　とりあえず解く
- 計算量
    - 時間：O(n)
    - 空間：O(1)
- ソート済みだったのでTwo Pointerパターンで両端から走査させてACできた

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int r = numbers.length-1;
        int l = 0;
        while(l < r){
            if(numbers[l] + numbers[r] > target){
                r--;
            }
            if(numbers[l] + numbers[r] < target){
                l++;
            }
            if(numbers[l] + numbers[r] == target){
                return new int[]{l+1, r+1}; 
            }
        }
        return new int[]{l+1, r+1}; 
    }
}
```


## step2 他の人の回答を見る
- HashMapを使う解法
- HashMapのkeyに値、valueにindex+1を入れてcontainsKeyで調べる
- 空間計算量がO(n)となること、ソート済みの配列を活かせていないため今回の問題には適していいないかなと
- 計算量
    - 時間：O(n)
    - 空間：O(n)

```java
public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        Map<Integer, Integer> mp = new HashMap<>();
        for (int i = 0; i < numbers.length; i++) {
            int tmp = target - numbers[i];
            if (mp.containsKey(tmp)) {
                return new int[] { mp.get(tmp), i + 1 };
            }
            mp.put(numbers[i], i + 1);
        }
        return new int[0];
    }
}
```

- 自分と同じTwo Pointerで解いた回答
- ifの分岐を見ると、私の回答のリファクタリングの余地を感じた
    - 私の回答では `numbers[l] + numbers[r]` を3回計算しているが変数として持つことで計算回数を減らせる

```java
public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length - 1;

        while (l < r) {
            int curSum = numbers[l] + numbers[r];

            if (curSum > target) {
                r--;
            } else if (curSum < target) {
                l++;
            } else {
                return new int[] { l + 1, r + 1 };
            }
        }
        return new int[0];
    }
}
```

## step3 3回解く
- Two Pointerを使った他人の回答を早期returnを使うように修正


```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int r = numbers.length-1;
        int l = 0;
        while(l < r){
            int curSum = numbers[l] + numbers[r];
            if(curSum > target){
                r--;
                continue;
            }
            if(curSum < target){
                l++;
                continue;
            }
            return new int[]{l+1, r+1};
        }
        return new int[]{0};
    }
}
```