## step1 とりあえず解く
- 計算量
  - 時間:O(log(m * n))
  - 空間:O(m * n)
- 単調増加することがわかっているので二分探索が使えた
- 二分探索しやすいように、二次元配列を一次元配列に変えて二分探索を実装
- 反省点としては、メソッド分割してもっとわかりやすいコードにできればよかった

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int totalElement = matrix.length * matrix[0].length;
        int[] flatMatrix = new int[totalElement];
        
        int index = 0;
        for (int[] row : matrix) {
            for (int element : row) {
                flatMatrix[index++] = element;
            }
        }
        
        int left = 0, right = totalElement - 1;
        while (left <= right) {
            int middle = (left + right) / 2;
            if (flatMatrix[middle] == target) {
                return true;
            } else if (flatMatrix[middle] > target) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }
        return false;
    }
}

```

## step2 他の人の回答を見る
- 計算量
  - 時間:O(log(m * n))
  - 空間:O(1)
- Step1の回答は1次元配列を作るために空間計算量が追加でかかっていたが、与えられた二次元配列のままで処理する回答を見つけた
  - この回答を思いつけなかったのが悲しい

```java
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int rows = matrix.length, cols = matrix[0].length;

        int left = 0, right = rows * cols - 1;
        while (left <= right) {
            int middle = left + (right - left) / 2;
            int row = middle / cols, col = middle % cols;
            if (target > matrix[row][col]) {
                left = middle + 1;
            } else if (target < matrix[row][col]) {
                right = middle - 1;
            } else {
                return true;
            }
        }
        return false;
    }
}

```

## step3 3回とく


```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        final int ROWS = matrix.length;
        final int COLUMNS = matrix[0].length;
        
        int left = 0, right = ROWS * COLUMNS - 1;
        
        while (left <= right) {
            int middle = left + (right - left) / 2;
            int row = middle / COLUMNS, column = middle % COLUMNS;

            if (matrix[row][column] == target) {
                return true;
            } else if (matrix[row][column] > target) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }
        return false;
    }
}

```
