## step1 とりあえず解く
- 計算量
  - 時間
  - 空間
- 問題の核のgetMin() を O(1) で取得する方法が思いつかず断念
- それ以外はArrayDequeのメソッドを呼び出すだけだった

```java
class MinStack {
    
    private final Deque<Integer> stack;

    private int min;

    public MinStack() {
        stack = new ArrayDeque<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int val) {
        stack.add(val);
        min = Math.min(min, val);
    }
    
    public void pop() {
        stack.pollLast();
        // ここでminをどうするかが実装できず
    }
    
    public int top() {
        return stack.getLast();
    }
    
    public int getMin() {
        return min;
    }
}

```

## step2 他の人の回答を見る
- 計算量
  - 時間:O(1)
  - 空間:O(N)
- getMinのためにMinを管理するStackを用意する方法
  - Minの履歴管理みたいな感じ

```java
public class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public void pop() {
        if (stack.isEmpty()) return;
        int top = stack.pop();
        if (top == minStack.peek()) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

- 変わり種としてStackを1つで済ませる方法もあった
- stackには値そのものではなくその時のminとの差分を入れる
  - topがよばれた時はpopの値が正であればmin+popする値を返すことで元の値を算出する
  - もしpopするときに負の値が出るようであればminが切り替わったサインとしてmin-popを行う方法っぽい
- 競プロとしては面白いが、コーディングテストとしては可読性が低くバグが混入しやすいので適さないかなと思った

```java
public class MinStack {
    long min;
    Stack<Long> stack;

    public MinStack() {
        stack = new Stack<>();
    }

    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(0L);
            min = val;
        } else {
            stack.push(val - min);
            if (val < min) min = val;
        }
    }

    public void pop() {
        if (stack.isEmpty()) return;

        long pop = stack.pop();

        if (pop < 0) min = min - pop;
    }

    public int top() {
        long top = stack.peek();
        if (top > 0) {
            return (int) (top + min);
        } else {
            return (int) min;
        }
    }

    public int getMin() {
        return (int) min;
    }
}
```

## step3 3回とく
- 素直にStackを2つ用意する方法でとく
- 前回教えていただいたパフォーマンスの良いArrayDequeをつかう
- ハマったところ
  - Integerの比較で `==` をつかうと-128から127の範囲(両端含む)の値を常にキャッシュするため比較がおかしいことがあるため注意が必要
  - https://docs.oracle.com/javase/jp/17/docs/api/java.base/java/lang/Integer.html

```java
class MinStack {

    private final ArrayDeque<Integer> stack;
    private final ArrayDeque<Integer> minStack;

    public MinStack() {
        this.stack = new ArrayDeque<>();
        this.minStack = new ArrayDeque<>();
    }
    
    public void push(int val) {
        this.stack.add(val);
        if (this.minStack.isEmpty() || val <= this.minStack.peekLast()) {
            this.minStack.add(val);
        }
    }
    
    public void pop() {
        if (this.stack.isEmpty()) {
            return;
        }

        if (this.stack.pollLast().equals(this.minStack.peekLast())){
            this.minStack.pollLast();
        }
    }
    
    public int top() {
        return this.stack.peekLast();
    }
    
    public int getMin() {
        return this.minStack.peekLast();
    }
}
```