## step1 とりあえず解く
- 計算量
  - 時間:O(N)
  - 空間:O(N)
- 方針としては配列を逆から読み、未来の最高値をStackに保存し最高販売益を計算した
- 振り返るとStackを使うまでもなかった
- Stackを使ったせいで空間計算量が上がってしまった

```java
class Solution {
    public int maxProfit(int[] prices) {
        Deque<Integer> deque = new ArrayDeque<>();
        int ans = 0;
        for (int i = prices.length - 1; 0 <= i; i --) {
            if (!deque.isEmpty() && prices[i] < deque.peekLast()) {
                ans = Math.max(ans, deque.peekLast() - prices[i]);
            } else {
                deque.add(prices[i]);
            }
        }
        return ans;
    }
}

```

## step2 他の人の回答を見る
- 計算量
  - 時間：O(N)
  - 空間：O(1)
- 一番安く買えた価格だけ保持すればいいことがわかったので、その値だけ保持する方針
- これが最良の気がする

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = prices[0];
        int ans = 0;
        for (int price : prices) {
            minPrice = Math.min(minPrice, price);
            ans = Math.max(price - minPrice, ans);
        }
        return ans;
    }
}

```

## step3 3回とく
- step2と同様