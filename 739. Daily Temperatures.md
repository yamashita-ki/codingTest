## step1 とりあえず解く
- 計算量
  - 時間:O(N^2)
  - 空間:O(N)
- 時間計算量をO(N)にする解決策を思いつけず、安直に全探索

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        for (int i = 0; i < temperatures.length - 1; i++) {
            for (int j = i + 1; j < temperatures.length; j++) {
                if (temperatures[i] < temperatures[j]) {
                    ans[i] = j - i;
                    break;
                }
            }
        }
        return ans;
    }
}
```

## step2 他の人の回答を見て気になるところを修正
- 計算量
  - 時間: O(N)
  - 空間: O(N)
- 単調増加、単調減少するように要素が並べられたStackはMonotonic Stackというらしい
- for文の中にwhile文があるためぱっと見時間計算量がO(N^2)に見えたが、各要素一度しかpop, pushされないためO(N)になる
- 単にstackに積むだけではなく、stackに積む前に積むあたいがstackの一番上の値より大きいか確認する
  - 大きければ、stackからpopする
  - この一連の動作により単調減少のstackが作れる
- stackに積むのはindexだけでいいかなと思ったが、おそらくわかりやすさのために温度もセットで積んでいる

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        ArrayDeque<int[]> stack = new ArrayDeque<>();
        int[] ans = new int[temperatures.length];

        for (int t = 0; t < temperatures.length; t++) {
            int temperature = temperatures[t];
            while (!stack.isEmpty() && temperature > stack.peekLast()[0]) {
                int[] pairs = stack.pollLast();
                ans[pairs[1]] = t - pairs[1];
            }
            stack.add(new int[]{temperature, t});
        }
        return ans;
    }
}
```

- 計算量
  - 時間: O(N)
  - 空間: O(N)
- 上記とは異なり右から（配列の後ろから）みていく方法
- ただ配列を右から見ていくというのが直感的ではない、若干認知負荷が高く感じてしまった

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int length = temperatures.length;
        Deque<Integer> stack = new ArrayDeque<>();
        int[] result = new int[length];
      
        for (int currentIndex = length - 1; currentIndex >= 0; currentIndex--) {
            while (!stack.isEmpty() && temperatures[stack.peek()] <= temperatures[currentIndex]) {
                stack.pop();
            }
          
            if (!stack.isEmpty()) {
                result[currentIndex] = stack.peek() - currentIndex;
            }
          
            stack.push(currentIndex);
        }
      
        return result;
    }
}
```

## step3 3回とく
- step2の配列の左から見ていく方法解いた

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        Deque<int[]> stack = new ArrayDeque<>();

        for (int t = 0; t < temperatures.length; t++) {
            int temperature = temperatures[t];
            while (!stack.isEmpty() && stack.peekLast()[1] < temperature) {
                int[] pair = stack.pollLast();
                ans[pair[0]] = t - pair[0];
            }
            stack.add(new int[]{t, temperature});
        }
        return ans;
    }
}
```