## step1 とりあえず解く
- 計算量
  - 時間: O(M * N)
    - N: 配列の長さ
    - M: 配列の中の最大の要素
  - 空間: O(1)
- 何も思いつかなかったので愚直にspeedを1つずつ大きくしていき `Return the minimum integer k such that you can eat all the bananas within h hours.` に当てはまるspeedを求めた

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int speed = 1;
        while (true) {
            int totalTime = 0;
            for (int pile : piles) {
                totalTime += Math.ceil((double)pile / speed);
            }

            if (totalTime <= h) {
                return speed;
            }
            speed++;
        }
    }
}

```

- 計算量
  - 時間: O(N * log(M))
    - N: 配列の長さ
    - M: 配列の中の最大の要素
  - 空間: O(1)
- 上記回答で二分探索できると気づけたので二分探索で対応
- int[] の最大値をStreamで求める方法が学びだった
  - `Arrays.stream(piles).max().getAsInt();`

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int minSpeed = 1;
        int maxSpeed = Arrays.stream(piles).max().getAsInt();
        int ans = 0;

        while (minSpeed <= maxSpeed) {
            int middleSpeed = minSpeed + (maxSpeed - minSpeed) / 2;
            int totalTime = 0;

            for (int pile : piles) {
                totalTime += Math.ceil((double)pile / middleSpeed);
            }
            
            if (h < totalTime) {
                minSpeed = middleSpeed + 1;
            } else {
                maxSpeed = middleSpeed - 1;
                ans = middleSpeed;
            }
        }
        return ans;
    }
}

```

## step2 他の人の回答を見る
- 計算量
  - 時間: O(N * log(M))
    - N: 配列の長さ
    - M: 配列の中の最大の要素
  - 空間: O(1)
- いくつか見たが2分探索が多かった
- long型でhoursを持つことで計算過程でオーバーフローすることを防いでいる
  - この観点は持てていなかった
- 制限時間内にバナナが食べ切れるかどうかのロジックを別メソッドに切り出して可読性を上げている

```java
public class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1;  
        int right = Arrays.stream(piles).max().getAsInt();
        int ans = right;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (canFinish(piles, h, mid)) {
                ans = mid;     
                right = mid - 1;
            } else {
                left = mid + 1; 
            }
        }
        return ans;
    }

    private boolean canFinish(int[] piles, int h, int k) {
        long hours = 0;
        for (int pile : piles) {
            hours += Math.ceil((double)pile / k);
        }
        return hours <= h;
    }
}
```

## step3 3回とく

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int minSpeed = 0;
        int maxSpeed = Arrays.stream(piles).max().getAsInt();
        int ans = 0;
        
        while (minSpeed <= maxSpeed) {
            int middleSpeed = minSpeed + (maxSpeed - minSpeed) / 2;
            if (canFinish(piles, middleSpeed, h)) {
                ans = middleSpeed;
                maxSpeed = middleSpeed - 1;
            } else {
                minSpeed = middleSpeed + 1;
            }
        }
        return ans;
    }
    
    private boolean canFinish(int[] piles, int middleSpeed, int h) {
        long totalTime = 0;
        for (int pile : piles) {
            totalTime += Math.ceil((double) pile / middleSpeed);
        }
        return totalTime <= h;
    }
}

```