## step1 何も見ずに解く
- 計算量
  - 時間計算量：O(nlogn)
    - 参考：https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/Arrays.html#sort(int%5B%5D)
  - 空間計算量：O(n)
- 「You must write an algorithm that runs in O(n) time.」と記載があったがSortする方法しか思い浮かばず
- 考慮漏れしエラーになったケース
  - 与えられたnumsが空の場合を考慮できずエラー

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0) return 0;

        Arrays.sort(nums);
        int maxStreak = 0;
        int currentStreak = 1;
        int previousNum = nums[0];

        for(int i = 1; i < nums.length; i++){
            if(previousNum == nums[i]){
                continue;
            }
            if(previousNum + 1 == nums[i]){
                currentStreak ++;
                previousNum = nums[i];
                continue;
            }
            maxStreak = Math.max(maxStreak, currentStreak);
            currentStreak = 1;
            previousNum = nums[i];
        }
        return Math.max(maxStreak, currentStreak);
    }
}
```



## step2 他の回答を見る
- 感想：
  - 入力値を数直線上に置いたときに、連続値の始まりかどうかの判別は「左隣の数値が存在するかどうか」という観点を持てていなかった
  - 重複する数値はノイズでしかないのでHash Setでもつという観点もなかった
  - longestの更新箇所が1箇所であること、登場する変数の少なさから可読性が高いので個人的には良さを感じている
- 計算量
  - 時間計算量：O(n)
  - 空間計算量：O(n)

```java
public class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        int longest = 0;

        for (int num : numSet) {
            if (!numSet.contains(num - 1)) {
                int length = 1;
                while (numSet.contains(num + length)) {
                    length++;
                }
                longest = Math.max(longest, length);
            }
        }
        return longest;
    }
}
```

## step3 3回ミスなく書く
- step2の回答が好みなのでそちらで実装

```java
public class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        int longest = 0;

        for (int num : numSet) {
            if (!numSet.contains(num - 1)) {
                int length = 1;
                while (numSet.contains(num + length)) {
                    length++;
                }
                longest = Math.max(longest, length);
            }
        }
        return longest;
    }
}
```