## step1 とりあえず解く
- 計算量
  - 時間：O(N^3)
  - 空間：O(N)
- Two Pointerを使って上手くできないか考えたが思いつかず
- 愚直に全探索した、重複の組み合わせを出さないように前段でソートしてSetに保持した

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int length = nums.length;
        Set<List<Integer>> ans = new HashSet<>();
        Arrays.sort(nums);
        for(int i = 0; i<length-2;i++){
            for(int j = i+1; j<length-1; j++){
                for(int k = j+1; k < length;k++){
                    if(nums[i] + nums[j] + nums[k] == 0){
                        ans.add(List.of(nums[i], nums[j], nums[k]));
                    }
                }
            }
        }
        return new ArrayList<>(ans);
    }
}
```

## step2 他の人の回答を見る
- a(問題文に存在する変数)を最初に確定させて、その先の区間をTwo Pointerで書くことで計算量を抑える方法
- aがすでに訪れた数値である場合は重複するためSkipする
- numsはソート済みなのでaが負の数でなければ、走査をやめる
- 計算量
  - 時間:O(N^2)
  - 空間:O(N)


```java
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) break;
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int l = i + 1, r = nums.length - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum > 0) {
                    r--;
                } else if (sum < 0) {
                    l++;
                } else {
                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    l++;
                    r--;
                    while (l < r && nums[l] == nums[l - 1]) {
                        l++;
                    }
                }
            }
        }
        return res;
    }
}
```

## step3 3回とく
- Step2の回答で解いた


```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int numLength = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        for(int i = 0; i < numLength; i++){
            if(nums[i] > 0) break;
            if(i>0 && nums[i] == nums[i-1]) continue;
            int r = numLength-1;
            int l = i+1;
            while(l<r){
                int curSum = nums[i] + nums[r] + nums[l];
                if(curSum < 0){
                    l++;
                    continue;
                }
                if(curSum > 0){
                    r--;
                    continue;
                }
                ans.add(Arrays.asList(nums[i], nums[l], nums[r]));
                l++;
                r--;
                while(l<r && nums[l] == nums[l-1]){
                    l++;
                }
            }
        }
        return ans;
    }
}
```