## step1 とりあえず解く
- 計算量
  - 時間:O(N)
  - 空間:O(N)
- 素直にArrayDequeをStackとして使用して求めた
- 見直すと `calculateFromOperator` というメソッド名は若干冗長に感じる
  - 計算に演算子と非演算子を渡すことは自然であるため `calculate` でよかったかも
- `calculateFromOperator` の分岐はswitch式のが簡潔にかけたと思う

```java
class Solution {

    public int evalRPN(String[] tokens) {
        ArrayDeque<Integer> numStack = new ArrayDeque<>();
        Set<String> operators = new HashSet<>(Arrays.asList("*", "-", "+", "/"));
        for (String token : tokens) {
            if (operators.contains(token)) {
                int rightNum = numStack.pollLast();
                int leftNum = numStack.pollLast();
                numStack.add(this.calculateFromOperator(leftNum, rightNum, token));
            } else {
                numStack.add(Integer.parseInt(token));
            }
        }
        return numStack.peekLast();
    }

    private int calculateFromOperator(int leftNum, int rightNum, String operator) {
        if (operator.equals("+")) {
            return leftNum + rightNum;
        }
        if (operator.equals("-")) {
            return leftNum - rightNum;
        }
        if (operator.equals("*")) {
            return leftNum * rightNum;
        }
        if (operator.equals("/")) {
            return leftNum / rightNum;
        }
        throw new RuntimeException();
    }
}

```

## step2 他の人の回答を見る
- 計算量
  - 時間:O(N)
  - 空間:O(N)
- やはりStackを使った回答が多かった
- 計算するメソッドは別で切り出したほうが、重複の削除や責任の分離という面でも良さそう

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for (String c : tokens) {
            if (c.equals("+")) {
                stack.push(stack.pop() + stack.pop());
            } else if (c.equals("-")) {
                int a = stack.pop();
                int b = stack.pop();
                stack.push(b - a);
            } else if (c.equals("*")) {
                stack.push(stack.pop() * stack.pop());
            } else if (c.equals("/")) {
                int a = stack.pop();
                int b = stack.pop();
                stack.push(b / a);
            } else {
                stack.push(Integer.parseInt(c));
            }
        }
        return stack.pop();
    }
}
```

- 再帰的に解く方法もあった
- 計算量
  - 時間:O(N)
  - 空間:O(N)

```java
public class Solution {
    public int evalRPN(String[] tokens) {
        List<String> tokenList = new ArrayList<>(Arrays.asList(tokens));
        return dfs(tokenList);
    }

    private int dfs(List<String> tokens) {
        String token = tokens.remove(tokens.size() - 1);

        if (!"+-*/".contains(token)) {
            return Integer.parseInt(token);
        }

        int right = dfs(tokens);
        int left = dfs(tokens);

        switch (token) {
            case "+":
                return left + right;
            case "-":
                return left - right;
            case "*":
                return left * right;
            case "/":
                return left / right;
        }

        return 0;
    }
}
```

## step3 3回とく
- 異常系の処理と、stackから値を取り出す前のチェックを追加

```java
class Solution {
    public int evalRPN(String[] tokens) {
        if(tokens.length == 0) {
            return 0;
        }

        ArrayDeque<Integer> stack = new ArrayDeque<>();
        Set<String> operators = new HashSet<>(Arrays.asList("-", "+", "*", "/"));

        for(String token : tokens) {
            if(operators.contains(token) && stack.size() >= 2) {
                int rightNum = stack.pollLast();
                int leftNum = stack.pollLast();
                stack.add(this.calculate(leftNum, rightNum, token));
            } else {
                stack.add(Integer.parseInt(token));
            }
        }
        return stack.peekLast();
    }

    private int calculate(int leftNum, int rightNum, String operator) {
        switch(operator) {
            case "+":
                return leftNum + rightNum;
            case "-":
                return leftNum - rightNum;
            case "*":
                return leftNum * rightNum;
            case "/":
                return leftNum / rightNum;
        }
        throw new RuntimeException();
    }
}

```