## step1 とりあえず解く
- 計算量
  - 時間:O(m * n)
  - 空間:O(m * n)
- 苦しみながらなんとかAC
- 振り返れば
  - 縦横にうまく進める方法がわからず愚直にif４つかいた
  - x,yっていう自分の変数に苦しめられた
  - 無限ループを防ぐためにすでに訪れたかどうか管理するための変数を作ったが不要だった
    - 塗り替えようとしているカラーと塗ろうとしているカラーが同じかどうか判断すればよき

```java
class Solution {
    
    private record Fill(int x, int y){}

    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        Deque<Fill> queue = new ArrayDeque<>();
        int imageHeight = image.length;
        int imageWidth = image[0].length;
        int targetColor = image[sr][sc];
        int[][] seen = new int[imageHeight][imageWidth];


        queue.addLast(new Fill(sr, sc));
        while (!queue.isEmpty()) {
            Fill fill = queue.pollFirst();
            image[fill.x()][fill.y()] = color;
            seen[fill.x()][fill.y()] = 1;
            if (isExistInImageFill(fill.x() + 1, fill.y(), imageHeight, imageWidth) && image[fill.x() + 1][fill.y()] == targetColor
                && seen[fill.x() + 1][fill.y()] == 0 ) {
                queue.addLast(new Fill(fill.x() + 1, fill.y()));
            }
            if (isExistInImageFill(fill.x() - 1, fill.y(), imageHeight, imageWidth) && image[fill.x() - 1][fill.y()] == targetColor
                && seen[fill.x() - 1][fill.y()] == 0) {
                queue.addLast(new Fill(fill.x() - 1, fill.y()));
            }
            if (isExistInImageFill(fill.x(), fill.y() + 1, imageHeight, imageWidth) && image[fill.x()][fill.y() + 1] == targetColor
                && seen[fill.x()][fill.y() + 1] == 0) {
                queue.addLast(new Fill(fill.x(), fill.y() + 1));
            }
            if (isExistInImageFill(fill.x(), fill.y() - 1, imageHeight, imageWidth) && image[fill.x()][fill.y() - 1] == targetColor
                && seen[fill.x()][fill.y() - 1] == 0) {
                queue.addLast(new Fill(fill.x(), fill.y() - 1));
            }
        }
        return image;
    }

    private boolean isExistInImageFill(int x, int y, int imageHeight, int imageWidth) {
        return (0 <= y && y < imageWidth && 0 <=x && x < imageHeight); 
    }
}
```

## step2 他の人の回答を見る
- 計算量
  - 時間:O(m * n)
  - 空間:O(m * n)
- 進む方向を二次元配列で持つことで処理がすっきりした

```java
class Solution {
    
    private record Fill(int row, int col){}

    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        int rowSize = image.length;
        int colSize = image[0].length;
        int originalColor = image[sr][sc];

        if (originalColor == color) {
            return image;
        }

        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        Deque<Fill> queue = new ArrayDeque<>();

        queue.addLast(new Fill(sr, sc));

        while (!queue.isEmpty()) {
            Fill fill = queue.pollFirst();
            image[fill.row()][fill.col()] = color;
            for(int[] direction : directions) {
                int nr = fill.row() + direction[0];
                int nc = fill.col() + direction[1];
                if (0 <= nr && nr < rowSize && 0 <= nc && nc < colSize && image[nr][nc] == originalColor) {
                    queue.addLast(new Fill(nr, nc));
                }
            }
        }
        return image;
    }
}
```

## step3 3回とく
- step2と同じ
